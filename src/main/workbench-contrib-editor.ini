[vs/workbench/browser/parts/editor/editorDropTarget]
fileTooLarge = 文件太大，未能在新编辑器中显示。请将其存储在文件资源管理器中，然后重试。

[vs/workbench/browser/parts/editor/editorQuickAccess]
closeEditor = 关闭编辑器
entryAriaLabelDirty = {0}，未存储
entryAriaLabelWithGroup = {0}, {1}
entryAriaLabelWithGroupDirty = {0}，未存储，{1}
noViewResults = 没有匹配的编辑器

[vs/workbench/contrib/bulkEdit/browser/bulkEdit.contribution]
Discard = 放弃重构
apply = 应用重构
cancel = 取消
cat = 重构预览
continue = 继续
detail = 点击“继续”以放弃以前的重构，并继续当前重构。
groupByFile = 按文件分组
groupByType = 按类型分组
overlap = 正在预览另一个重构。
panel = 重构预览
toogleSelection = 切换更改

[vs/workbench/contrib/bulkEdit/browser/bulkEditPane]
conflict.1 = 无法应用重构，因为 {0} 个文件在重构发生前被更改了。
conflict.N = 无法应用重构，因为 {0} 个文件在重构发生前被更改了。
create = 创建
edt.title.1 = {0}（重构预览）
edt.title.2 = {0}（{1}、重构预览）
edt.title.del = {0}（删除、重构预览）
empty.msg = 使用代码操作时可在此查看更改预览。
rename = 重命名

[vs/workbench/contrib/bulkEdit/browser/bulkEditPreview]
default = 其他

[vs/workbench/contrib/bulkEdit/browser/bulkEditTree]
aria.create = 创建 {0}
aria.createAndEdit = 创建 {0}，同时进行文本编辑
aria.del = 行 {0}，正在删除 {1}
aria.delete = 删除 {0}
aria.deleteAndEdit = 正在删除 {0}，同时进行文本编辑
aria.editOnly = {0}，进行文本编辑
aria.insert = 行 {0}，插入 {1}
aria.rename = 将 {0} 重命名为 {1}
aria.renameAndEdit = 将 {0} 重命名为{1}，同时进行文本编辑
aria.replace = 行 {0}，用 {2} 替换 {1}
bulkEdit = 批量编辑
detail.create = （创建）
detail.del = （删除）
detail.rename = （重命名）
rename.label = {0} → {1}
title = {0} — {1}

[vs/workbench/contrib/codeActions/common/codeActionsContribution]
codeActionsOnSave = 在存储时运行的代码操作类型。
codeActionsOnSave.fixAll = 在存储文件时运行自动修复操作。
codeActionsOnSave.generic = 在存储文件时运行“{0}”操作。

[vs/workbench/contrib/codeActions/common/codeActionsExtensionPoint]
contributes.codeActions = 配置资源要使用的编辑器。
contributes.codeActions.description = 代码操作的说明。
contributes.codeActions.kind = 代码操作的种类。
contributes.codeActions.languages = 启用代码操作的语言模式。
contributes.codeActions.title = 用户界面中使用的代码操作的标签。

[vs/workbench/contrib/codeActions/common/documentationExtensionPoint]
contributes.documentation = 贡献的文档。
contributes.documentation.refactoring = 为重构提供了文档。
contributes.documentation.refactoring.command = 命令已执行。
contributes.documentation.refactoring.title = UI 中使用的文档的标签。
contributes.documentation.refactoring.when = when 子句。
contributes.documentation.refactorings = 为重构提供了文档。

[vs/workbench/contrib/codeEditor/browser/accessibility/accessibility]
ShowAccessibilityHelpAction = 显示辅助功能帮助
auto_off = 编辑器被配置为自动检测是否附加了屏幕阅读器，当前未检测到。
auto_on = 编辑器自动检测到已附加屏幕阅读器。
auto_unknown = 编辑器被配置为使用平台 API 以检测是否附加了屏幕阅读器，但当前运行时不支持此功能。
changeConfigToOnMac = 要设置对屏幕阅读器优化，请按 Command+E。
changeConfigToOnWinLinux = 要设置为对屏幕阅读器优化，请按 Ctrl+E。
configuredOff = 已设置为不对屏幕阅读器优化。
configuredOn = 已设置为对屏幕阅读器优化，您可以更改 `editor.accessibilitySupport` 设置。
emergencyConfOn = 现在将 `editor.accessibilitySupport` 设置更改为 `"on"`。
introMsg = 感谢试用 VS Code 的辅助功能选项。
openDocMac = 按 Command+H 键以打开浏览器窗口，其中包含更多有关 VS Code 辅助功能的信息。
openDocWinLinux = 按 Ctrl+H 键以打开浏览器窗口，其中包含更多有关 VS Code 辅助功能的信息。
openingDocs = 正在打开 VS Code 辅助功能文档页面。
outroMsg = 按 Esc 键或 Shift+Esc 键以消除此工具提示并返回到编辑器。
status = 状态：
tabFocusModeOffMsg = 在当前编辑器中按 Tab 键将插入制表符。通过按 {0} 切换此行为。
tabFocusModeOffMsgNoKb = 在当前编辑器中按 Tab 键会插入制表符。当前未能通过快捷键触发命令 {0}。
tabFocusModeOnMsg = 在当前编辑器中按 Tab 键会将焦点移动到下一个可聚焦的元素。通过按 {0} 切换此行为。
tabFocusModeOnMsgNoKb = 在当前编辑器中按 Tab 键会将焦点移动到下一个可聚焦的元素。当前未能通过快捷键触发命令 {0}。

[vs/workbench/contrib/codeEditor/browser/diffEditorHelper]
hintTimeout = 差异算法已提前停止（在 {0} 毫秒后）
hintWhitespace = 显示空白差异
removeTimeout = 删除限制

[vs/workbench/contrib/codeEditor/browser/find/simpleFindWidget]
label.closeButton = 关闭
label.find = 查找
label.nextMatchButton = 下一个匹配项
label.previousMatchButton = 上一个匹配项
placeholder.find = 查找

[vs/workbench/contrib/codeEditor/browser/inspectEditorTokens/inspectEditorTokens]
inspectEditorTokens = 开发者：检查词素分析结果
inspectTMScopesWidget.loading = 正在加载词素分析信息…

[vs/workbench/contrib/codeEditor/browser/inspectKeybindings]
developer = 开发者
workbench.action.inspectKeyMap = 开发者：检查键盘映射
workbench.action.inspectKeyMapJSON = 检查键盘映射（JSON）

[vs/workbench/contrib/codeEditor/browser/languageConfigurationExtensionPoint]
formatError = {0}：格式无效，应为 JSON 对象。
parseErrors = 错误分析 {0}：{1}
schema.autoCloseBefore = 在自动闭合设置为 `"languageDefined"` 时，定义使括号或引号自动闭合的光标后面的字符。通常是不会成为表达式开头的一组字符。
schema.autoClosingPairs = 定义括号对。当输入左方括号时，将自动插入右方括号。
schema.autoClosingPairs.notIn = 定义禁用了自动配对的作用域列表。
schema.blockComment.begin = 作为块注释开头的字符序列。
schema.blockComment.end = 作为块注释结尾的字符序列。
schema.blockComments = 定义块注释的标记方式。
schema.brackets = 定义增加和减少缩进的括号。
schema.closeBracket = 右方括号字符或字符串序列。
schema.comments = 定义注释符号
schema.folding = 此语言的折叠设置。
schema.folding.markers = 语言特定的折叠标记，如 `"#region"` 与 `"#endregion"`。开始与结束标记的正则表达式需设计得效率高，因其将对每一行的内容进行测试。
schema.folding.markers.end = 结束标记的正则表达式模式。其应以 `^` 开始。
schema.folding.markers.start = 开始标记的正则表达式模式。其应以 `^` 开始。
schema.folding.offSide = 在使用缩进标记代码块（off-side rule）的语言中，空白行将属于其之后的代码块。
schema.indentationRules = 语言的缩进设置。
schema.indentationRules.decreaseIndentPattern = 如果某行文本匹配此模式，则其后所有行都应被取消缩进一次（直到匹配其他规则）
schema.indentationRules.decreaseIndentPattern.errorMessage = 必须匹配模式 `/^([gimuy]+)$/`。
schema.indentationRules.decreaseIndentPattern.flags = decreaseIndentPattern 的正则表达式开关。
schema.indentationRules.decreaseIndentPattern.pattern = decreaseIndentPattern 的正则表达式模式。
schema.indentationRules.increaseIndentPattern = 如果一行文本匹配此模式，则之后所有内容都应被缩进一次（直到匹配其他规则）。
schema.indentationRules.increaseIndentPattern.errorMessage = 必须匹配模式 `/^([gimuy]+)$/`。
schema.indentationRules.increaseIndentPattern.flags = increaseIndentPattern 的正则表达式开关。
schema.indentationRules.increaseIndentPattern.pattern = increaseIndentPattern 的正则表达式模式。
schema.indentationRules.indentNextLinePattern = 如果某一行匹配此模式，那么仅此行之后的**下一行**应缩进一次。
schema.indentationRules.indentNextLinePattern.errorMessage = 必须匹配模式 `/^([gimuy]+)$/`。
schema.indentationRules.indentNextLinePattern.flags = indentNextLinePattern 的正则表达式开关。
schema.indentationRules.indentNextLinePattern.pattern = indentNextLinePattern 的正则表达式模式。
schema.indentationRules.unIndentedLinePattern = 如果某一行匹配此模式，那么不应更改此行的缩进，且不应针对其他规则对其进行计算。
schema.indentationRules.unIndentedLinePattern.errorMessage = 必须匹配模式 `/^([gimuy]+)$/`。
schema.indentationRules.unIndentedLinePattern.flags = unIndentedLinePattern 的正则表达式开关。
schema.indentationRules.unIndentedLinePattern.pattern = unIndentedLinePattern 的正则表达式模式。
schema.lineComment = 作为行注释开头的字符序列。
schema.openBracket = 左方括号字符或字符串序列。
schema.surroundingPairs = 定义可用于包围所选字符串的括号对。
schema.wordPattern = 定义在编程语言里什么东西会被当做是一个单词。
schema.wordPattern.flags = 用于匹配文本的正则表达式开关。
schema.wordPattern.flags.errorMessage = 必须匹配模式 `/^([gimuy]+)$/`。
schema.wordPattern.pattern = 用于匹配文本的正则表达式模式。

[vs/workbench/contrib/codeEditor/browser/largeFileOptimizations]
largeFile = {0}：为减少内存使用并避免卡顿或崩溃，我们已关闭对此大型文件内容的标记、折行和折叠。
removeOptimizations = 强制启用功能
reopenFilePrompt = 请重新打开文件以使此设置生效。

[vs/workbench/contrib/codeEditor/browser/saveParticipants]
codeAction.apply = 正在执行代码操作“{0}”。
codeaction = 快速修复
codeaction.get = 正在从“{0}”获取代码操作。[设置](command: workbench.action.openSettings?%5B%22editor.codeActionsOnSave%22%5D)
formatting = 正在执行“{0}”格式化操作。[设置](command: workbench.action.openSettings?%5B%22editor.formatOnSave%22%5D)

[vs/workbench/contrib/codeEditor/browser/toggleColumnSelection]
miColumnSelection = 打开或关闭列选择模式(&&S)
toggleColumnSelection = 打开或关闭列选择模式

[vs/workbench/contrib/codeEditor/browser/toggleMinimap]
miShowMinimap = 显示小地图(&&M)
toggleMinimap = 显示或隐藏小地图
view = 视图

[vs/workbench/contrib/codeEditor/browser/toggleMultiCursorModifier]
miMultiCursorAlt = 切换为按住 Alt 键添加光标
miMultiCursorCmd = 切换为按住 Command 键添加光标
miMultiCursorCtrl = 切换为按住 Ctrl 键添加光标
toggleLocation = 切换多行修改键

[vs/workbench/contrib/codeEditor/browser/toggleRenderControlCharacter]
miToggleRenderControlCharacters = 渲染控制字符(&&C)
toggleRenderControlCharacters = 显示或隐藏控制字符
view = 视图

[vs/workbench/contrib/codeEditor/browser/toggleRenderWhitespace]
miToggleRenderWhitespace = 渲染空格(&&R)
toggleRenderWhitespace = 显示或隐藏空格
view = 视图

[vs/workbench/contrib/codeEditor/browser/toggleWordWrap]
miToggleWordWrap = 打开或关闭自动换行(&&W)
toggle.wordwrap = 视图：打开或关闭自动换行
unwrapMinified = 在此文件禁用折行
wordWrap.notInDiffEditor = 不能在差异编辑器中打开或关闭自动换行。
wrapMinified = 在此文件启用折行

[vs/workbench/contrib/codeEditor/electron-browser/selectionClipboard]
actions.pasteSelectionClipboard = 粘贴选区剪贴板

[vs/workbench/contrib/codeEditor/electron-browser/startDebugTextMate]
developer = 开发者
startDebugTextMate = 启动文本配对语法语法日志记录

[vs/workbench/contrib/codeEditor/electron-sandbox/selectionClipboard]
actions.pasteSelectionClipboard = 粘贴选择剪贴板

[vs/workbench/contrib/customEditor/browser/customEditors]
openWithCurrentlyActive = 当前处于活动状态
promptOpenWith.placeHolder = 选择要用于“{0}”的编辑器…
promptOpenWith.setDefaultTooltip = 设置为“{0}”文件的默认编辑器

[vs/workbench/contrib/customEditor/common/contributedCustomEditors]
builtinProviderDisplayName = 内置
promptOpenWith.defaultEditor.displayName = 文本编辑器

[vs/workbench/contrib/emmet/browser/actions/expandAbbreviation]
expandAbbreviationAction = 补全 Emmet
miEmmetExpandAbbreviation = 补全 Emmet(&&X)

[vs/workbench/contrib/emmet/browser/actions/showEmmetCommands]
miShowEmmetCommands = Emmet(&&M)…
showEmmetCommands = 显示 Emmet 命令

[vs/workbench/contrib/format/browser/formatActionsMultiple]
config = 配置默认格式化程序…
config.bad = 扩展“{0}”配置为格式化程序，但不可用。选择其他默认格式化程序以继续。
config.needed = {0} 文件有多个格式化程序。选择一个默认格式化程序以继续操作。
def = （默认值）
do.config = 配置…
format.placeHolder = 选择格式化程序
formatDocument.label.multiple = 格式化文档，方法是使用…
formatSelection.label.multiple = 格式选择与…
formatter.default = 定义一个默认格式化程序，该格式化程序优先于所有其他格式化程序设置。应是提供格式化程序的扩展的标识符。
miss = 扩展“{0}”未能格式化“{1}”
nullFormatterDescription = 没有
select = 为 {0} 文件选择默认格式化程序

[vs/workbench/contrib/format/browser/formatActionsNone]
formatDocument.label.multiple = 设置文档的格式
install.formatter = 安装格式化程序…
no.provider = 当前没有安装“{0}”文件的格式化程序。

[vs/workbench/contrib/notebook/browser/contrib/coreActions]
changeLanguage = 更改单元格语言
clearActiveCellOutputs = 清除活动单元格输出
clearAllCellsOutputs = 清除所有单元格输出
cursorMoveDown = 向下移动光标
cursorMoveUp = 向上移动光标
focusFirstCell = 聚焦到第一个单元格
focusLastCell = 聚焦到最后一个单元格
focusOutput = 聚焦到活动单元格输出
focusOutputOut = 取消聚焦活动单元格输出
languageDescription = （{0}）— 当前语言
languageDescriptionConfigured = （{0}）
notebookActions.CancelCell = 取消执行
notebookActions.cancel = 停止单元格执行
notebookActions.cancelNotebook = 取消笔记本执行
notebookActions.category = 笔记本
notebookActions.centerActiveCell = 中心活动单元格
notebookActions.changeCellToCode = 将单元格更改为代码
notebookActions.changeCellToMarkdown = 将单元格更改为 Markdown
notebookActions.copy = 拷贝单元格
notebookActions.copyCellDown = 在下方复制单元格
notebookActions.copyCellUp = 在上方复制单元格
notebookActions.cut = 剪切单元格
notebookActions.deleteCell = 删除单元格
notebookActions.editCell = 编辑单元格
notebookActions.execute = 执行单元格
notebookActions.executeAndInsertBelow = 执行笔记本单元格并在下方插入
notebookActions.executeAndSelectBelow = 执行笔记本单元格并在下方选择
notebookActions.executeCell = 执行单元格
notebookActions.executeNotebook = 执行笔记本
notebookActions.insertCodeCellAbove = 在上方插入代码单元格
notebookActions.insertCodeCellBelow = 在下方插入代码单元格
notebookActions.insertMarkdownCellAbove = 在上方插入 Markdown 单元格
notebookActions.insertMarkdownCellBelow = 在下方插入 Markdown 单元格
notebookActions.joinCellAbove = 与上一个单元格合并
notebookActions.joinCellBelow = 与下一个单元格合并
notebookActions.menu.cancelNotebook = 停止笔记本执行
notebookActions.menu.execute = 执行笔记本单元格
notebookActions.menu.executeNotebook = 执行笔记本中所有单元格
notebookActions.moveCellDown = 向下移动单元格
notebookActions.moveCellUp = 向上移动单元格
notebookActions.paste = 粘贴单元格
notebookActions.pasteAbove = 在上方粘贴单元格
notebookActions.quitEdit = 停止编辑单元格
notebookActions.renderMarkdown = 呈现所有 Markdown 单元格
notebookActions.splitCell = 拆分单元格
pickLanguageToConfigure = 选择语言模式
redo = 重做
undo = 撤销

[vs/workbench/contrib/notebook/browser/contrib/find/findController]
notebookActions.findInNotebook = 在笔记本中查找
notebookActions.hideFind = 隐藏“在笔记本中查找”

[vs/workbench/contrib/notebook/browser/contrib/fold/folding]
fold.cell = 折叠单元格
unfold.cell = 展开单元格

[vs/workbench/contrib/notebook/browser/contrib/format/formatting]
format.title = 设置笔记本的格式
formatCell.label = 设置单元格格式
label = 设置笔记本的格式

[vs/workbench/contrib/notebook/browser/contrib/status/editorStatus]
currentActiveBuiltinKernel = （当前，内置）
currentActiveKernel = （当前）
notebookActions.selectKernel = 选择笔记本内核
pickAction = 选择操作

[vs/workbench/contrib/notebook/browser/extensionPoint]
contributes.notebook.provider = 提供笔记本文档处理程序。
contributes.notebook.provider.displayName = 笔记本的可读名称。
contributes.notebook.provider.selector = 适用于笔记本的一组 glob 模式。
contributes.notebook.provider.selector.filenamePattern = 启用笔记本的 glob 模式。
contributes.notebook.provider.viewType = 笔记本的唯一标识符。
contributes.notebook.renderer = 提供笔记本输出渲染器。
contributes.notebook.renderer.displayName = 笔记本输出渲染器的可读名称。
contributes.notebook.renderer.viewType = 笔记本输出渲染器的唯一标识符。
contributes.notebook.selector = 适用于笔记本的一组 glob 模式。
contributes.notebook.selector.provider.excludeFileNamePattern = 禁用笔记本的 glob 模式。

[vs/workbench/contrib/notebook/browser/notebook.contribution]
notebook.displayOrder.description = 输出项 MIME 类型的优先级列表
notebookConfigurationTitle = 笔记本

[vs/workbench/contrib/notebook/browser/notebookEditorWidget]
cellToolbarSeperator = 单元格底部工具栏中的分隔符颜色
notebook.cellBorderColor = 笔记本单元格的边框颜色。
notebook.cellStatusBarItemHoverBackground = 笔记本单元格状态栏项的背景色。
notebook.focusedCellIndicator = 聚焦的笔记本单元格指示符的颜色。
notebook.outputContainerBackgroundColor = 笔记本输出容器背景的颜色。
notebookStatusErrorIcon.foreground = 单元格状态栏中笔记本单元格的错误图标颜色。
notebookStatusRunningIcon.foreground = 单元格状态栏中笔记本单元格的“正在运行”图标颜色。
notebookStatusSuccessIcon.foreground = 单元格状态栏中笔记本单元格的错误图标颜色。
notebookTreeAriaLabel = 笔记本

[vs/workbench/contrib/notebook/browser/notebookServiceImpl]
builtinProviderDisplayName = 内置

[vs/workbench/contrib/notebook/browser/view/renderers/codeCell]
builtinRenderInfo = 内置
curruentActiveMimeType = 当前活动
mimeTypePicker = 选择其他输出 MIME 类型，可用的 MIME 类型：{0}
promptChooseMimeType.placeHolder = 为当前输出项选择要渲染的 MIME 类型

[vs/workbench/contrib/snippets/browser/configureSnippets]
bad_name1 = 文件名无效
bad_name2 = “{0}”不是有效的文件名
bad_name3 = “{0}”已存在
global.1 = （{0}）
global.scope = （全局）
group.global = 现有代码片段
miOpenSnippets = 代码片段(&&S)
name = 代码片段名称
new.folder = 新建“{0}”文件夹的代码片段文件…
new.global = 新建全局代码片段文件…
new.global.sep = 新代码片段
new.global_scope = 全局
new.workspace_scope = {0} 工作区
openSnippet.label = 配置代码片段
openSnippet.pickLanguage = 选择代码片段文件或创建代码片段
preferences = 设置
userSnippets = 代码片段

[vs/workbench/contrib/snippets/browser/insertSnippet]
sep.extSnippet = 扩展代码片段
sep.userSnippet = 代码片段
sep.workspaceSnippet = 工作区代码片段
snippet.suggestions.label = 插入片段

[vs/workbench/contrib/snippets/browser/snippetCompletionProvider]
detail.snippet = {0}（{1}）
snippetSuggest.longLabel = {0}，{1}

[vs/workbench/contrib/snippets/browser/snippets.contribution]
snippetSchema.json = 代码片段配置
snippetSchema.json.body = 代码片段的内容。使用 `$1` 和 `${1:defaultText}` 定义光标位置，使用 `$0` 定义最终光标位置。使用 `${varName}` 和 `${varName:defaultText}` 插入变量值，例如 `This is file: $TM_FILENAME`。
snippetSchema.json.default = 空代码片段
snippetSchema.json.description = 代码片段描述。
snippetSchema.json.prefix = 在智能感知中选择代码片段时将使用的前缀
snippetSchema.json.scope = 此代码片段适用语言的名称列表，例如 `"typescript,javascript"`。

[vs/workbench/contrib/snippets/browser/snippetsFile]
source.userSnippet = 代码片段
source.userSnippetGlobal = 全局代码片段
source.workspaceSnippetGlobal = 工作区代码片段

[vs/workbench/contrib/snippets/browser/snippetsService]
badFile = 未能读取代码片段文件 `{0}`。
badVariableUse = 扩展 `{0}` 中的一个或多个代码片段很可能混淆了片段变量和片段占位符（详细信息请见 https://code.visualstudio.com/docs/editor/userdefinedsnippets#_snippet-syntax）
invalid.language = `contributes.{0}.language` 属性值包含未知语言。提供的值为 {1}
invalid.language.0 = 省略语言时，`contributes.{0}.path` 属性值必须指向一个“.code-snippets”文件。提供的值为 {1}
invalid.path.0 = `contributes.{0}.path` 属性值应是字符串。提供的值为 {1}
invalid.path.1 = `contributes.{0}.url` 属性值（{1}）未包含在扩展所在的文件夹（{2}）内。这可能使扩展不可移植。
vscode.extension.contributes.snippets = 贡献代码段。
vscode.extension.contributes.snippets-language = 此代码片段参与的语言标识符。
vscode.extension.contributes.snippets-path = 代码片段文件的路径，相对于扩展文件夹。
