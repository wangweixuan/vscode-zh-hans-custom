[vs/workbench/contrib/tasks/browser/abstractTaskService]
ConfigureTaskRunnerAction.label = 配置任务
TaskServer.folderIgnored = 由于使用任务版本 0.1.0，文件夹 {0} 将被忽略
TaskServer.noTask = 未定义要执行的任务
TaskService.associate = 关联
TaskService.attachProblemMatcher.continueWithout = 继续而不扫描任务输出
TaskService.attachProblemMatcher.learnMoreAbout = 了解有关扫描任务输出的详细信息
TaskService.attachProblemMatcher.never = 永不扫描任务输出
TaskService.attachProblemMatcher.neverType = 从不扫描 {0} 个任务的任务输出
TaskService.createJsonFile = 使用模板创建 tasks.json 文件
TaskService.defaultBuildTaskExists = {0} 已被标记为默认生成任务
TaskService.defaultTestTaskExists = {0} 已被标记为默认测试任务。
TaskService.fetchingBuildTasks = 正在获取生成任务…
TaskService.fetchingTestTasks = 正在获取测试任务…
TaskService.ignoredFolder = 由于使用任务版本 0.1.0，以下工作区文件夹将被忽略：{0}
TaskService.learnMore = 了解详细信息
TaskService.noBuildTask = 没有找到要运行的生成任务。配置生成任务…
TaskService.noBuildTask1 = 未定义任何生成任务。使用 `isBuildCommand` 属性在 tasks.json 文件中标记任务。
TaskService.noBuildTask2 = 未定义任何生成任务。在 tasks.json 文件中将任务标记为生成任务。
TaskService.noConfiguration = 错误：{0} 任务检测没有提供拥有下列配置的任务：\n{1}\n将忽略此任务。\n
TaskService.noEntryToRun = 没有找到要运行的任务。配置任务…
TaskService.noTaskIsRunning = 没有运行中的任务
TaskService.noTaskRunning = 当前没有运行中的任务
TaskService.noTaskToRestart = 没有要重新启动的任务
TaskService.noTestTask1 = 未定义任何测试任务。使用 `isTestCommand` 属性在 tasks.json 文件中标记任务。
TaskService.noTestTask2 = 未定义任何测试任务。在 tasks.json 文件中将任务标记为测试任务。
TaskService.noTestTaskTerminal = 没有找到要运行的测试任务。配置任务…
TaskService.noWorkspace = 任务仅在工作区文件夹上可用。
TaskService.notAgain = 不再显示
TaskService.openJsonFile = 打开 tasks.json 文件
TaskService.pickBuildTask = 选择要运行的生成任务
TaskService.pickBuildTaskForLabel = 选择生成任务（未定义默认生成任务）
TaskService.pickDefaultBuildTask = 选择要用作默认生成任务的任务
TaskService.pickDefaultTestTask = 选择要用作默认测试任务的任务
TaskService.pickRunTask = 选择要运行的任务
TaskService.pickShowTask = 选择要显示输出的任务
TaskService.pickTask = 选择要配置的任务
TaskService.pickTestTask = 选择要运行的测试任务
TaskService.taskToRestart = 选择要重新启动的任务
TaskService.taskToTerminate = 选择要终止的任务
TaskService.template = 选择任务模板
TaskService.terminateAllRunningTasks = 所有正在运行的任务
TaskSystem.active = 当前已有任务正在运行。请先终止它，然后再执行另一项任务。
TaskSystem.activeSame.noBackground = 任务“{0}”已处于活动状态。
TaskSystem.configurationErrors = 错误：提供的任务配置具有验证错误，未能使用。请首先改正错误。
TaskSystem.exitAnyways = 仍然退出(&&E)
TaskSystem.invalidTaskJson = 错误：tasks.json 文件的内容具有语法错误。请先更正错误然后再执行任务。\n
TaskSystem.invalidTaskJsonOther = 错误：{0} 中的 tasks.json 文件的内容存在语法错误。请在执行任务之前更正它们。
TaskSystem.noHotSwap = 在有活动任务运行时更换任务执行引擎需要重新加载窗口
TaskSystem.noProcess = 启动的任务不再存在。如果任务已生成出后台进程，则退出 VS Code 可能会导致出现孤立的进程。若要避免此情况，请使用等待标记启动最后一个后台进程。
TaskSystem.restartFailed = 未能终止并重新启动任务 {0}
TaskSystem.runningTask = 存在运行中的任务。要终止它吗？
TaskSystem.terminateTask = 终止任务(&&T)
TaskSystem.unknownError = 运行任务时出错。请参见任务日志了解详细信息。
TaskSystem.versionSettings = 用户设置中只允许版本为 2.0.0 的任务。
TaskSystem.versionWorkspaceFile = 工作区中只允许 2.0.0 版本的任务。
TasksSystem.locationUserConfig = 用户设置
TasksSystem.locationWorkspaceConfig = 工作区文件
TerminateAction.failed = 未能终止运行中的任务
TerminateAction.label = 终止任务
TerminateAction.noProcess = 启动的进程不再存在。如果任务生成的后台任务退出 VS Code，则可能会导致出现孤立的进程。
configureTask = 配置任务
configured = 已配置的任务
customizeParseErrors = 当前任务配置存在错误。请先更正错误，再自定义任务。
detected = 检测到的任务
moreThanOneBuildTask = 当前 tasks.json 中定义了多个生成任务。正在执行第一个。\n
pickProgressManager.description = 正在检测任务（第 {0} 项，共 {1} 项）：正在进行 {2}
recentlyUsed = 最近使用的任务
reloadWindow = 重新加载窗口
restartTask = 重新启动任务
selectProblemMatcher = 选择针对何种错误和警告扫描任务输出
showOutput = 显示输出
taskQuickPick.cancel = 停止检测
taskQuickPick.userSettings = 用户设置
taskService.ignoreingFolder = 将忽略工作区文件夹 {0} 的任务配置。多文件夹工作区任务支持要求所有文件夹使用任务版本 2.0.0\n
taskServiceOutputPrompt = 任务出现错误。请查看输出结果，了解更多详细信息
tasks = 任务
tasksJsonComment = // 要了解 tasks.json 文件的格式，请访问\n	// https://go.microsoft.com/fwlink/?LinkId=733558
terminateTask = 终止任务

[vs/workbench/contrib/tasks/browser/runAutomaticTasks]
allow = 允许并运行
disallow = 不允许
openTasks = 打开 tasks.json
tasks.run.allowAutomatic = 此文件夹已在 tasks.json 中定义任务（{0}）；打开此文件夹时，这些任务将自动运行。是否自动任务在您打开此文件夹时运行？
workbench.action.tasks.allowAutomaticTasks = 允许文件夹中的自动任务
workbench.action.tasks.disallowAutomaticTasks = 禁止文件夹中的自动任务
workbench.action.tasks.manageAutomaticRunning = 管理文件夹中的自动任务

[vs/workbench/contrib/tasks/browser/task.contribution]
BuildAction.label = 运行生成任务
ConfigureDefaultBuildTask.label = 配置默认生成任务
ConfigureDefaultTestTask.label = 配置默认测试任务
ReRunTaskAction.label = 重新运行上一个任务
RestartTaskAction.label = 重新启动正在运行的任务
RunTaskAction.label = 运行任务
ShowLogAction.label = 显示任务日志
ShowTasksAction.label = 显示运行中的任务
TerminateAction.label = 终止任务
TestAction.label = 运行测试任务
building = 正在生成…
miBuildTask = 运行生成任务(&&B)…
miConfigureBuildTask = 配置默认生成任务(&&F)…
miConfigureTask = 配置任务(&&C)…
miRestartTask = 重新启动任务(&&E)…
miRunTask = 运行任务(&&R)…
miRunningTask = 显示正在运行的任务(&&G)…
miTerminateTask = 终止任务(&&T)…
quickOpen.task = 运行任务
runningTasks = 显示运行中的任务
status.runningTasks = 运行任务
task.autoDetect = 允许所有任务提供程序扩展提供任务。如果运行任务命令速度较慢，则禁用任务提供程序的自动检测可能会有所帮助。单个扩展可以提供设置禁用自动检测。
task.problemMatchers.neverPrompt = 在运行任务时关闭问题匹配器提示。
task.problemMatchers.neverPrompt.array = 包含任务类型布尔对的对象，从不提示有问题的匹配者。
task.problemMatchers.neverPrompt.boolean = 为所有任务设置问题匹配器提示行为。
task.quickOpen.detail = 在“运行任务”快速选取中显示具有详细信息的任务的任务详细信息。
task.quickOpen.history = 任务快速打开对话框中跟踪的最近项目数。
task.quickOpen.skip = 当只有一个任务要选取时是否跳过任务快速选取。
task.slowProviderWarning = 当提供程序速度较慢时是否显示警告。
task.slowProviderWarning.array = 从不显示慢速提供程序警告的任务类型的数组。
task.slowProviderWarning.boolean = 为所有任务设置慢速提供程序警告。
tasksCategory = 任务
tasksConfigurationTitle = 任务
workbench.action.tasks.openUserTasks = 显示用户任务
workbench.action.tasks.openWorkspaceFileTasks = 显示工作区任务

[vs/workbench/contrib/tasks/browser/terminalTaskSystem]
TerminalTaskSystem = 未能使用 cmd.exe 在 UNC 驱动器上执行 shell 命令。
TerminalTaskSystem.nonWatchingMatcher = 任务 {0} 是后台任务，但使用的问题匹配器没有后台模式。
TerminalTaskSystem.terminalName = 任务 — {0}
TerminalTaskSystem.unknownError = 在执行任务时发生未知错误。请参见任务输出日志了解详细信息。
closeTerminal = 按任意键关闭终端。
dependencyFailed = 未能解析在工作区文件夹“{1}”中的依赖任务“{0}”
reuseTerminal = 终端将被任务重用，按任意键关闭。
unknownProblemMatcher = 未能解析问题匹配程序 {0}。此匹配程序将被忽略

[vs/workbench/contrib/tasks/common/jsonSchemaCommon]
JsonSchema.args = 传递到命令的其他参数。
JsonSchema.background = 已执行的任务是否保持活动状态并在后台运行。
JsonSchema.command = 要执行的命令。可以是外部程序或 shell 命令。
JsonSchema.echoCommand = 是否将已执行的命令回显到输出。默认为 `false`。
JsonSchema.matchers = 要使用的问题匹配程序。可以是字符串或问题匹配程序定义，或字符串和问题匹配程序数组。
JsonSchema.options = 其他命令选项
JsonSchema.options.cwd = 已执行程序或脚本的当前工作目录。默认为 VS Code 的工作区根目录。
JsonSchema.options.env = 已执行程序或 shell 的环境变量。默认为父进程的环境变量。
JsonSchema.promptOnClose = 在具有正在运行的后台任务的情况下关闭 VS Code 时是否提示用户。
JsonSchema.shell.args = shell 参数。
JsonSchema.shell.executable = 待使用的 shell。
JsonSchema.shellConfiguration = 配置使用的 shell。
JsonSchema.showOutput = 是否显示运行任务的输出。默认为 `"always"`。
JsonSchema.suppressTaskName = 是否将任务名作为参数添加到命令。默认为 `false`。
JsonSchema.taskSelector = 指示参数是任务的前缀。
JsonSchema.tasks = 任务配置。通常是外部任务运行程序中已定义任务的扩充。
JsonSchema.tasks.args = 在调用此任务时传递给命令的参数。
JsonSchema.tasks.background = 已执行的任务是否保持活动状态并在后台运行。
JsonSchema.tasks.build = 将此任务映射到代码的默认生成命令。
JsonSchema.tasks.linux = Linux 特定的命令配置
JsonSchema.tasks.mac = macOS 特定的命令配置
JsonSchema.tasks.matchers = 要使用的问题匹配程序。可以是字符串或问题匹配程序定义，或字符串和问题匹配程序数组。
JsonSchema.tasks.promptOnClose = 当 VS 代码与运行的任务一起关闭时是否提示用户。
JsonSchema.tasks.showOutput = 是否显示正在运行的任务的输出。如果省略，则使用全局定义的值。
JsonSchema.tasks.suppressTaskName = 是否将任务名作为参数添加到命令。如果省略，则使用全局定义的值。
JsonSchema.tasks.taskName = 任务名称
JsonSchema.tasks.test = 将此任务映射到代码的默认测试命令。
JsonSchema.tasks.watching = 已执行的任务是否保持活动状态，并且是否在监视文件系统。
JsonSchema.tasks.watching.deprecation = 已弃用：请改用 `isBackground`。
JsonSchema.tasks.windows = Windows 特定的命令配置
JsonSchema.watching = 已执行的任务是否保持活动状态，并且是否在监视文件系统。
JsonSchema.watching.deprecation = 已弃用：请改用 `isBackground`。

[vs/workbench/contrib/tasks/common/jsonSchema_v1]
JsonSchema._runner = 此 runner 已完成使命。请使用官方 runner 属性。
JsonSchema.linux = Linux 特定的命令配置
JsonSchema.mac = macOS 特定的命令配置
JsonSchema.runner = 定义任务是否作为进程执行，输出显示在输出窗口还是在终端内。
JsonSchema.shell = 指定命令是 shell 命令还是外部程序。如果省略，默认为 `false`。
JsonSchema.version = 配置的版本号
JsonSchema.version.deprecated = 任务版本 0.1.0 已弃用，请使用 2.0.0。
JsonSchema.windows = Windows 特定的命令配置

[vs/workbench/contrib/tasks/common/jsonSchema_v2]
JsonSchema.args.quotedString.value = 实际参数值。
JsonSchema.args.quotesString.quote = 参数值应该如何引用。
JsonSchema.command = 要执行的命令。可以是外部程序或 shell 命令。
JsonSchema.command.quotedString.value = 实际命令值。
JsonSchema.command.quotesString.quote = 如何引用命令值。
JsonSchema.commandArray = 执行的 shell 命令。数组项将使用空格连接。
JsonSchema.customizations.customizes.type = 要自定义的任务类型。
JsonSchema.linux = Linux 特定的命令配置。
JsonSchema.mac = macOS 特定的命令配置。
JsonSchema.shell = 指定命令是 shell 命令还是外部程序。默认为 `false`。
JsonSchema.tasks.args = 在调用此任务时传递给命令的参数。
JsonSchema.tasks.background = 已执行的任务是否保持活动状态并在后台运行。
JsonSchema.tasks.customize.deprecated = 已弃用：请参见 1.14 发行说明了解如何迁移到新的自定义任务。
JsonSchema.tasks.dependsOn = 表示另一个任务的字符串或此任务所依赖的其他任务的数组。
JsonSchema.tasks.dependsOn.array = 此任务依赖的其他任务。
JsonSchema.tasks.dependsOn.identifier = 任务标识符。
JsonSchema.tasks.dependsOn.string = 此任务依赖的另一任务。
JsonSchema.tasks.dependsOrder = 此任务依赖的其他任务的运行顺序。不可使用递归。
JsonSchema.tasks.dependsOrder.parallel = 并行运行其他任务。
JsonSchema.tasks.dependsOrder.sequence = 串行运行其他任务。
JsonSchema.tasks.detail = 任务的可选说明，在“运行任务”快速选取中作为详细信息显示。
JsonSchema.tasks.echoCommand.deprecated = 已弃用：请改用 `presentation` 属性中的 `echo` 属性。参见 1.14 发行说明。
JsonSchema.tasks.group = 定义此任务属于的执行组。可为 `"build"` 以将其添加到生成组，`"test"` 以将其添加到测试组。
JsonSchema.tasks.group.build = 将任务标记为可通过“运行生成任务”命令访问的生成任务。
JsonSchema.tasks.group.defaultBuild = 将此任务标记为默认生成任务。
JsonSchema.tasks.group.defaultTest = 将此任务标记为默认测试任务。
JsonSchema.tasks.group.isDefault = 定义此任务是否为组中的默认任务。
JsonSchema.tasks.group.kind = 任务的执行组。
JsonSchema.tasks.group.none = 将任务分配为没有组
JsonSchema.tasks.group.test = 将任务标记为测试任务。
JsonSchema.tasks.identifier = 用于在 launch.json 或“dependsOn”子句中引用任务的用户定义标识符。
JsonSchema.tasks.identifier.deprecated = 已弃用用户定义的标识符。对于自定义任务，请使用名称进行引用；对于由扩展提供的任务，请使用其中定义的任务标识符。
JsonSchema.tasks.instanceLimit = 允许同时运行的任务的数量。
JsonSchema.tasks.isBuildCommand.deprecated = 已弃用：请改用 `group` 属性。参见 1.14 发行说明。
JsonSchema.tasks.isShellCommand.deprecated = 已弃用：请改用任务的 `type` 属性和选项中的 `shell` 属性。参见 1.14 发行说明。
JsonSchema.tasks.isTestCommand.deprecated = 已弃用：请改用 `group` 属性。参见 1.14 发行说明。
JsonSchema.tasks.label = 显示给用户的任务标签
JsonSchema.tasks.matchers = 要使用的问题匹配程序。可以是字符串或问题匹配程序定义，或字符串和问题匹配程序数组。
JsonSchema.tasks.presentation = 配置用于显示任务输出和读取输入的面板。
JsonSchema.tasks.presentation.clear = 是否在执行任务之前清除终端。
JsonSchema.tasks.presentation.echo = 是否将执行的命令显示到面板中。默认为 `true`。
JsonSchema.tasks.presentation.focus = 面板是否获取焦点。默认为 `false`。
JsonSchema.tasks.presentation.group = 是否使用拆分窗格在特定终端组中执行任务。
JsonSchema.tasks.presentation.instance = 是否在任务间共享面板。同一个任务使用相同面板还是每次运行时新创建一个面板。
JsonSchema.tasks.presentation.reveal = 是否显示运行任务的面板。适用于 `revealProblems` 选项没有指定时。默认为 `"always"`。
JsonSchema.tasks.presentation.reveal.always = 始终显示面板。
JsonSchema.tasks.presentation.reveal.never = 从不显示面板。
JsonSchema.tasks.presentation.reveal.silent = 只在任务报错并退出，或问题匹配程序发现错误时显示面板。
JsonSchema.tasks.presentation.revealProblems = 在运行任务时是否显示问题面板。优先于 `reveals` 选项。默认为 `"never"`。
JsonSchema.tasks.presentation.revealProblems.always = 始终显示问题面板。
JsonSchema.tasks.presentation.revealProblems.never = 从不显示问题面板。
JsonSchema.tasks.presentation.revealProblems.onProblem = 只在发现问题时显示问题面板。
JsonSchema.tasks.presentation.showReuseMessage = 是否显示“终端将被任务重用，按任意键关闭”提示。
JsonSchema.tasks.promptOnClose = 当 VS 代码与运行的任务一起关闭时是否提示用户。
JsonSchema.tasks.quoting.escape = 使用 shell 的转义字符来转义文本，如 PowerShell 中的 `\\` 和 bash 中的 `\\\\`）
JsonSchema.tasks.quoting.strong = 使用 shell 的强引用字符来引用参数，如 PowerShell 和 bash 中的 `"`）
JsonSchema.tasks.quoting.weak = 使用 shell 的弱引用字符来引用参数，如 PowerShell 和 bash 中的 `'`）
JsonSchema.tasks.reevaluateOnRerun = 是否在重新运行时重新评估任务变量。
JsonSchema.tasks.runOn = 对该任务何时运行进行配置。设置为 `"folderOpen"` 表示那么该任务将在文件夹打开时自动运行。
JsonSchema.tasks.runOptions = 任务的运行相关选项
JsonSchema.tasks.showOutput.deprecated = 已弃用：请改用 `presentation` 属性内的 `reveal` 属性。另请参见 1.14 发行说明。
JsonSchema.tasks.suppressTaskName.deprecated = 已弃用：请改为在任务中内嵌命令及其参数。另请参见 1.14 发行说明。
JsonSchema.tasks.taskLabel = 任务标签
JsonSchema.tasks.taskName = 任务名称
JsonSchema.tasks.taskName.deprecated = 已弃用：请改用 `label`。
JsonSchema.tasks.taskSelector.deprecated = 已弃用：请改为在任务中内嵌命令及其参数。另请参见 1.14 发行说明。
JsonSchema.tasks.terminal = 已弃用：请改用 `presentation`。
JsonSchema.tasks.type = 定义任务是被作为进程运行还是在 shell 中作为命令运行。
JsonSchema.version = 配置的版本号。
JsonSchema.windows = Windows 特定的命令配置

[vs/workbench/contrib/tasks/common/problemMatcher]
LegacyProblemMatcherSchema.watchedBegin = 一个正则表达式，发出受监视任务开始执行（通过文件监视触发）的信号。
LegacyProblemMatcherSchema.watchedBegin.deprecated = 已弃用：请改用 `watching`。
LegacyProblemMatcherSchema.watchedEnd = 一个正则表达式，发出受监视任务结束执行的信号。
LegacyProblemMatcherSchema.watchedEnd.deprecated = 已弃用：请改用 `watching`。
NamedMultiLineProblemPatternSchema.name = 问题多行问题模式的名称。
NamedMultiLineProblemPatternSchema.patterns = 实际模式。
NamedProblemMatcherSchema.label = 显示给用户的问题匹配程序标签。
NamedProblemMatcherSchema.name = 要引用的问题匹配程序的名称。
NamedProblemPatternSchema.name = 问题模式的名称。
PatternTypeSchema.description = 问题模式或者所提供或预定义问题模式的名称。如果已指定 `base`，则可以省略。
PatternTypeSchema.name = 所提供或预定义模式的名称
ProblemMatcherExtPoint = 提供问题匹配程序
ProblemMatcherParser.invalidRegexp = 错误：字符串 {0} 不是有效的正则表达式。\n
ProblemMatcherParser.noDefinedPatter = 错误：标识符为 {0} 的模式不存在。
ProblemMatcherParser.noFileLocation = 错误：描述未定义文件位置：\n{0}\n
ProblemMatcherParser.noIdentifier = 错误：模式属性引用空标识符。
ProblemMatcherParser.noOwner = 错误：描述未指定所有者：\n{0}\n
ProblemMatcherParser.noProblemMatcher = 错误：描述未能转换为问题匹配程序：\n{0}\n
ProblemMatcherParser.noProblemPattern = 错误：描述未定义有效的问题模式：\n{0}\n
ProblemMatcherParser.noValidIdentifier = 错误：模式属性 {0} 是无效的模式变量名。
ProblemMatcherParser.problemPattern.watchingMatcher = 问题匹配程序必须定义监视的开始模式和结束模式。
ProblemMatcherParser.unknownSeverity = 信息：未能识别严重性 `"{0}"`。有效值为 `"error"`、`"warning"` 和 `"info"`。\n
ProblemMatcherSchema.applyTo = 文本文档上报告的问题是否仅应用于打开、关闭或所有文档。
ProblemMatcherSchema.background = 用于跟踪在后台任务上激活的匹配程序的开始和结束的模式。
ProblemMatcherSchema.background.activeOnStart = 在任务开始时激活后台监控。这相当于发出与 `beginPattern` 匹配的行。
ProblemMatcherSchema.background.beginsPattern = 如果在输出内匹配，则会发出后台任务开始的信号。
ProblemMatcherSchema.background.endsPattern = 如果在输出内匹配，则会发出后台任务结束的信号。
ProblemMatcherSchema.base = 要使用的基问题匹配程序的名称。
ProblemMatcherSchema.fileLocation = 定义应如何解释问题模式中报告的文件名。
ProblemMatcherSchema.owner = 代码内问题的所有者。如果指定了 `base`，则可省略。如果省略，并且未指定 `base`，则默认为 `"external"`。
ProblemMatcherSchema.severity = 捕获问题的默认严重性。如果模式未定义严重性的匹配组，则使用。
ProblemMatcherSchema.source = 显示给用户的诊断信息来源，如 `"typescript"` 或 `"super lint"`。
ProblemMatcherSchema.watching = 用于跟踪监视匹配程序开始和结束的模式。
ProblemMatcherSchema.watching.activeOnStart = 在任务开始时观察程序处于活动模式。这相当于发出与 `beginPattern` 匹配的行。
ProblemMatcherSchema.watching.beginsPattern = 如果在输出内匹配，则在监视任务开始时会发出信号。
ProblemMatcherSchema.watching.deprecated = 已弃用：请改用 `background`。
ProblemMatcherSchema.watching.endsPattern = 如果在输出内匹配，则在监视任务结束时会发出信号。
ProblemPatternExtPoint = 提供问题模式
ProblemPatternParser.invalidRegexp = 错误：字符串 {0} 不是有效的正则表达式。\n
ProblemPatternParser.loopProperty.notLast = 循环属性仅在最一个行匹配程序上受支持。
ProblemPatternParser.problemPattern.kindProperty.notFirst = 问题模式无效。`kind` 属性必须提供，且仅能为第一个元素
ProblemPatternParser.problemPattern.missingLocation = 问题模式无效。它应是 `file`，代码行或消息匹配组其中的一项。
ProblemPatternParser.problemPattern.missingProperty = 问题模式无效。必须至少包含一个文件和一条消息。
ProblemPatternParser.problemPattern.missingRegExp = 问题模式缺少正则表达式。
ProblemPatternRegistry.error = 无效问题模式。此模式将被忽略。
ProblemPatternSchema.code = 问题代码的匹配组索引。默认为 `undefined`。
ProblemPatternSchema.column = 问题行字符的匹配组索引。默认为 `3`。
ProblemPatternSchema.endColumn = 问题结束行字符的匹配组索引。默认为 `undefined`。
ProblemPatternSchema.endLine = 问题结束行的匹配组索引。默认为 `undefined`。
ProblemPatternSchema.file = 文件名的匹配组索引。默认为 `1`。
ProblemPatternSchema.kind = 模式匹配的是一个位置（文件、一行）还是仅为一个文件。
ProblemPatternSchema.line = 问题行的匹配组索引。默认为 `2`。
ProblemPatternSchema.location = 问题位置的匹配组索引。有效的位置模式为 (line)、(line,column) 和 (startLine,startColumn,endLine,endColumn)。默认为 (line,column)。
ProblemPatternSchema.loop = 在多行中，匹配程序循环指示是否只要匹配就在循环中执行此模式。只能在多行模式的最后一个模式上指定。
ProblemPatternSchema.message = 消息的匹配组索引。如果省略，则在指定了位置时默认为 `4`，在其他情况下默认为 `5`。
ProblemPatternSchema.regexp = 用于在输出中查找错误、警告或信息的正则表达式。
ProblemPatternSchema.severity = 问题严重性的匹配组索引。默认为 `undefined`。
WatchingPatternSchema.file = 文件名的匹配组索引。可以省略。
WatchingPatternSchema.regexp = 用于检测后台任务开始或结束的正则表达式。
eslint-compact = ESLint compact 问题
eslint-stylish = ESLint stylish 问题
go = Go 问题
gulp-tsc = Gulp TSC 问题
jshint = JSHint 问题
jshint-stylish = JSHint stylish 问题
lessCompile = Less 问题
msCompile = MS Build 问题

[vs/workbench/contrib/tasks/common/taskConfiguration]
ConfigurationParser.inValidArg = 错误：命令参数应是字符串或有效引用的字符串。提供的值为 ：{0}
ConfigurationParser.incorrectType = 错误：任务配置“{0}”使用了未知类型。已忽略该任务。
ConfigurationParser.invalidCWD = 警告：`options.cwd` 属性值应是字符串。将忽略值 {0}。\n
ConfigurationParser.invalidVariableReference = 错误：无效的 `problemMatcher` 引用：{0}\n
ConfigurationParser.missingType = 错误：任务配置“{0}”缺失必要属性 `type`。已忽略该任务。
ConfigurationParser.noName = 错误：声明范围内的问题匹配程序必须具有名称：\n{0}\n
ConfigurationParser.noShell = 警告：仅当在终端中执行任务时支持 shell 配置。
ConfigurationParser.noTaskName = 错误：任务未提供 `label` 属性。已忽略该任务。\n{0}\n
ConfigurationParser.noTaskType = 错误：任务未提供 `type` 属性。已忽略该任务。\n{0}\n
ConfigurationParser.noTypeDefinition = 错误：没有注册任务类型“{0}”。请确认是否安装含有相应任务提供器的扩展。
ConfigurationParser.notCustom = 错误：任务未声明为自定义任务。已忽略该任务。\n{0}\n
ConfigurationParser.unknownMatcherKind = 警告：定义的问题匹配程序未知。支持的类型为 `string | ProblemMatcher | Array<string | ProblemMatcher>`。\n{0}
TaskParse.noOsSpecificGlobalTasks = 任务版本 2.0.0 不支持全局操作系统特定任务。请将他们转换为含有操作系统特定命令的任务。受影响的任务有：\n{0}
taskConfiguration.noCommand = 错误：任务“{0}”没有指定命令。已忽略该任务。其定义为：\n{1}
taskConfiguration.noCommandOrDependsOn = 错误：任务“{0}”没有指定命令，也没有指定 `dependsOn` 属性。已忽略该任务。其定义为：\n{1}

[vs/workbench/contrib/tasks/common/taskDefinitionRegistry]
TaskDefinition.description = 实际任务类型。请以“$”开头的类型仅保留内部使用。
TaskDefinition.properties = 任务类型的其他属性
TaskDefinitionExtPoint = 配置任务种类
TaskTypeConfiguration.noType = 任务类型配置缺少必需的 `taskType` 属性

[vs/workbench/contrib/tasks/common/taskTemplates]
Maven = 执行常见的 maven 命令
dotnetCore = 执行 .NET Core 生成命令
externalCommand = 运行任意外部命令的示例
msbuild = 执行生成目标

[vs/workbench/contrib/tasks/common/tasks]
TaskDefinition.missingRequiredProperty = 错误：任务标识符“{0}”缺失必要属性 `{1}`。将忽略该标识符。

[vs/workbench/contrib/tasks/node/processRunnerDetector]
TaskSystemDetector.buildTaskDetected = 检测到名为“{0}”的生成任务。
TaskSystemDetector.noGruntProgram = 没有安装 Grunt。运行 `npm install -g grunt` 以安装它。
TaskSystemDetector.noGulpProgram = 没有安装 Gulp。运行 `npm install -g gulp-cli` 以安装它。
TaskSystemDetector.noGulpTasks = 没有找到 Gulp 任务。请确认是否运行了 `npm install`。
TaskSystemDetector.noJakeProgram = 没有安装 Jake。运行 `npm install -g jake` 以安装它。
TaskSystemDetector.noJakeTasks = 没有找到 Jake 任务。请确认是否运行了 `npm install`。
TaskSystemDetector.noProgram = 找不到程序 {0}。消息是 {1}
TaskSystemDetector.testTaskDetected = 测试检测到的名为“{0}”的测试任务。

[vs/workbench/contrib/tasks/node/processTaskSystem]
TaskRunnerSystem.cancelRequested = \n已根据用户请求终止了任务“{0}”
TaskRunnerSystem.childProcessError = 启动外部程序{0} {1}失败。
TaskRunnerSystem.unknownError = 在执行任务时发生未知错误。请参见任务输出日志了解详细信息。
TaskRunnerSystem.watchingBuildTaskFinished = \n监视生成任务已完成
unknownProblemMatcher = 未能解析问题匹配程序 {0}。此匹配程序将被忽略
version1_0 = 任务系统配置的版本为 0.1.0（可参见 tasks.json 文件），只能执行自定义任务。请升级到版本 2.0.0 以运行任务：{0}
